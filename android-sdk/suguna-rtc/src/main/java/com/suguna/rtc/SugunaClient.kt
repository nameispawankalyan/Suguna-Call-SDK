package com.suguna.rtc

import android.content.Context
import io.livekit.android.LiveKit
import io.livekit.android.LiveKitOverrides
import io.livekit.android.events.RoomEvent
import io.livekit.android.events.collect
import io.livekit.android.room.Room
import io.livekit.android.room.participant.Participant
import io.livekit.android.room.participant.RemoteParticipant
import io.livekit.android.room.participant.VideoTrack
import io.livekit.android.room.track.Track
import io.livekit.android.room.track.VideoTrack as LiveKitVideoTrack
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

/**
 * SugunaClient - Powered by LiveKit
 * Unified Architecture for 1-vs-1 and Live Streaming
 */
class SugunaClient(
    private val context: Context,
    private val serverUrl: String // Now points to LiveKit WebSocket URL
) {
    private var room: Room? = null
    private val scope = CoroutineScope(Dispatchers.Main)

    interface SugunaEvents {
        // We pass 'Any' here to hide implementation, or we can create a SugunaVideoTrack wrapper.
        // For simplicity now, we treat track as an opaque object for the consumer.
        fun onLocalStreamReady(videoTrack: Any)
        fun onRemoteStreamReady(userId: String, videoTrack: Any)
        fun onUserLeft(userId: String)
        fun onError(message: String)
    }

    companion object {
        const val ROLE_HOST = "host"
        const val ROLE_AUDIENCE = "audience"
        
        /**
         * Helper to attach a track to a view without exposing LiveKit logic to the App.
         */
        fun attachTrackToView(track: Any, view: SugunaVideoView) {
            if (track is LiveKitVideoTrack) {
                track.addRenderer(view)
            }
        }
    }

    private var eventListener: SugunaEvents? = null

    fun setEventListener(listener: SugunaEvents) {
        this.eventListener = listener
    }

    /**
     * initializes and connects to the room.
     * @param roomId: The name of the room to join
     * @param rtcToken: The JWT token generated by your server
     * @param role: ROLE_HOST (can publish) or ROLE_AUDIENCE (can only subscribe)
     */
    fun initialize(roomId: String, rtcToken: String, role: String = ROLE_HOST) {
        scope.launch {
            try {
                // Initialize Room
                room = LiveKit.create(context, overrides = LiveKitOverrides(adaptiveStream = true))

                // Setup Listeners
                setupRoomListeners()

                // Connect to LiveKit Cloud
                room?.connect(serverUrl, rtcToken)
                
                // If Host, start publishing immediately
                if (role == ROLE_HOST) {
                    startLocalStream()
                }

            } catch (e: Exception) {
                eventListener?.onError("Connection Failed: ${e.message}")
                e.printStackTrace()
            }
        }
    }

    private fun setupRoomListeners() {
        scope.launch {
            room?.events?.collect { event ->
                when (event) {
                    is RoomEvent.TrackSubscribed -> {
                        val track = event.track
                        val participant = event.participant
                        
                        if (track is LiveKitVideoTrack) {
                            eventListener?.onRemoteStreamReady(participant.identity ?: "unknown", track)
                        }
                    }
                    is RoomEvent.ParticipantDisconnected -> {
                        eventListener?.onUserLeft(event.participant.identity ?: "unknown")
                    }
                    is RoomEvent.Disconnected -> {
                        eventListener?.onUserLeft("local_user")
                    }
                    else -> {}
                }
            }
        }
    }

    private fun startLocalStream() {
        scope.launch {
            // Enable Camera & Mic
            room?.localParticipant?.setCameraEnabled(true)
            room?.localParticipant?.setMicrophoneEnabled(true)

            // Get the local video track to show in UI
            val videoTrack = room?.localParticipant?.videoTrackPublications?.firstOrNull()?.second as? LiveKitVideoTrack
            
            // Note: In LiveKit, local track might take a moment to be published.
            // We can also grab it directly from the LocalParticipant if needed immediately,
            // but usually setting camera enabled triggers the track creation.
            
            // For preview, we often use a separate preview view, but here we'll wait for the track.
        }
    }

    fun joinRoom() {
        // In LiveKit, 'connect' joins the room. 
        // We already called connect in initialize.
        // This method is kept for backward compatibility or can be used for explicit joining if logic changes.
    }

    fun leaveRoom() {
        room?.disconnect()
        room?.release()
        room = null
    }

    // --- Media Controls ---

    fun switchCamera() {
        val track = room?.localParticipant?.getTrackPublication(Track.Source.CAMERA)?.track as? io.livekit.android.room.track.LocalVideoTrack
        track?.switchCamera()
    }

    fun muteLocalAudio(muted: Boolean) {
        room?.localParticipant?.setMicrophoneEnabled(!muted)
    }

    fun muteLocalVideo(muted: Boolean) {
        room?.localParticipant?.setCameraEnabled(!muted)
    }
}
